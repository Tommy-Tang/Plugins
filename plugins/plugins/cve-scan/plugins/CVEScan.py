## Minimum required imports
import base64
import codecs
import hashlib
import json
import os
import re
import sys
import traceback
import __main__
callLocation = os.path.dirname(os.path.realpath(__main__.__file__))
sys.path.append(os.path.join(callLocation, ".."))

from bson           import json_util
from datetime       import datetime
from libnmap.parser import NmapParser
from uuid           import uuid4
from jinja2         import Environment, FileSystemLoader
from weasyprint     import HTML
from flask          import Flask, render_template

import lib.CVEs as cves
import lib.DatabaseLayer as db
from lib.Plugins import Plugin, WebPlugin
from lib.Toolkit import toStringFormattedCPE

class CVEScan(WebPlugin):
  def __init__(self):
    self.name = "CVE-Scan"
    self.requiresAuth = False
    self.tempPath = "/tmp/CVEScan-pdfs"

    env = Environment(loader=FileSystemLoader(callLocation))
    self.pdf  = env.get_template("templates/plugins/cve-scan_pdf.html")
    self.html = "plugins/cve-scan_webdisplay.html"
    self.collection = "CVEScan"

  def onCVEAction(self, cve, action, **args):
    if action in ["json", "pdf", "webview"]:
      try:
        data  = args["fields"]['scan'][0]
        store = bool(args["fields"]['store'][0])
        tags  = args["fields"]['tags'][0].split(",")
        notes = args["fields"]['notes'][0]

        nmap     = self._parseNMap(data)
        if store: self._store_in_db(nmap, tags=tags, notes=notes)
        enhanced = self._enhance(nmap)
        if   action == "json":
          returndata = json.dumps(enhanced, indent=2, default=json_util.default)
        elif action == "pdf":
          returndata = str(base64.b64encode(self._generatePDF(enhanced)), "utf-8")
        elif action == "webview":
          app = Flask(__name__, template_folder=os.path.join(callLocation, "templates"))
          with app.test_request_context("/"):
            returndata = render_template(self.html, scan=enhanced)
        return {'status': 'plugin_action_complete', 'data': returndata}
      except Exception as e:
        traceback.print_exc()
    elif action in ["save_settings"]:
      try:
        print(args["fields"])
        data = {"reaper.enable": bool(args["fields"]["reaper_enable"][0]),
                "reaper.folder":      args["fields"]["reaper_folder"][0],
                "reaper.store":  bool(args["fields"]["reaper_store"][0]),
                "output.enable": bool(args["fields"]["output_enable"][0]),
                "output.type":        args["fields"]["output_type"][0],
                "output.folder":      args["fields"]["output_folder"][0] }
        if data["output.type"] not in ["json", "pdf", "webview"]: return False
        if not data["reaper.folder"]: data["reaper.folder"] = "./cve-scan"
        if not data["output.folder"]: data["output.folder"] = "./cve-scan-output"
        for key, val in data.items():
          db.p_writeSetting(self.collection, key, val)
      except Exception as e:
        print(e)
        return False
      return True
    return False


  def getPage(self, **args):
    return ("cve-scan.html", {'plug_id': self.getUID()})

  def getSubpage(self, page, **args):
    if page.lower() == "settings":
      data = {'plug_id': self.getUID(),
              'reaper_enable': self._getSetting("reaper.enable", False),
              'reaper_folder': self._getSetting("reaper.folder", "./cve-search"),
              'reaper_store':  self._getSetting("reaper.store", True),
              'output_enable': self._getSetting("output.enable", True),
              'output_type':   self._getSetting("output.type", "json"),
              'output_folder': self._getSetting("output.folder", "./cve-search-output")}
      return ("cve-scan_settings.html", data)

  # CVE Scan code
  def _parseNMap(self, data):
    try:
      report = NmapParser.parse_fromstring(data)
    except Exception as e:
      print(e)
      raise(Exception)
    systems = []
    for h in report.hosts:
      system = {'mac':h.mac, 'ip':h.address, 'status':h.status, 'hostnames': h.hostnames,
                'vendor':h.vendor, 'distance':h.distance}
      cpeList = []
      for c in h.os_match_probabilities():
        for x in c.get_cpe():
          cpeList.append(x)
      cpeList=list(set(cpeList))
      if len(cpeList)>0:
        system['cpes']=cpeList
      services = []
      for s in h.services:
        service={'port':s.port, 'banner':s.banner, 'protocol':s.protocol, 'name':s.service,
                 'state':s.state, 'reason':s.reason}
        if s.cpelist:
          service['cpe'] = s.cpelist[0].cpestring
        services.append(service)
      system['services']=services
      systems.append(system)
    scan={"systems":systems, "scan": {"time": report.endtime, 
                                      "type": report._nmaprun["args"]}}
    return scan

  def _enhance(self, scan):
    cvesp = cves.last(rankinglookup=False, namelookup=False, vfeedlookup=True, capeclookup=False)
    for system in scan['systems']:
      cpe=system['cpes'] if 'cpes' in system else None

      if cpe:
        cpes=[]
        for c in cpe:
          c=c.lower()
          cpes.append({'cpe':c, 'cves':[cvesp.getcve(x['id'])
                       for x in db.cvesForCPE(toStringFormattedCPE(c))]})
        system['cpes']=cpes
      for service in system['services']:
        if 'cpe' in service:
          service['cves']=db.cvesForCPE(service['cpe'])
    scan['enhanced']={"time": int(datetime.now().strftime('%s'))}
    return scan

  def _generatePDF(self, parsed):
    try:
      filename = os.path.join(self.tempPath, "%s.pdf"%str(uuid4()))
      if not os.path.exists(self.tempPath): os.makedirs(self.tempPath)
      self._pdfify(parsed, filename)
      return open(filename, "rb").read()
    except Exception as e:
      print(e)
      raise(PDFGenerationException)

  def _pdfify(self, enhanced, output):
    enhanced["scan"]["time"] = self._fromEpoch(enhanced["scan"]["time"])
    enhanced["enhanced"]["time"] = self._fromEpoch(enhanced["enhanced"]["time"])
    appendixes=[]
    appendix = 1
    for system in enhanced["systems"]:
      if "cpes" in system:
        for cpe in system["cpes"]:
          cpe["cpe"] = self._toHuman(cpe["cpe"])
          if "cves" in cpe and len(cpe["cves"])!=0:
            appendixes.append(cpe["cves"])
            cpe.pop("cves")
            cpe["appendix"]=appendix
            appendix += 1
      for service in system["services"]:
        service["banner"]=self._product(service["banner"])
        if "cves" in service and len(service["cves"])!=0:
          appendixes.append(service["cves"])
          service["appendix"] = appendix
          appendix += 1
        if "cves" in service: service.pop("cves")
    enhanced["appendixes"]=appendixes
    html_out = self.pdf.render(enhanced)
    HTML(string=html_out).write_pdf(output)

  def _fromEpoch(self, epoch):
    return datetime.fromtimestamp(epoch).strftime('%a %d %h %Y at %H:%M:%S')

  def _toHuman(self, cpe):
    cpe = cpe[7:]
    result = cpe.split(':')[0] + " - "
    for c in cpe.split(':')[1:]:
      c = c.replace(':', ' ')
      c = c.replace('_', ' ')
      result += (" %s" %(c))
    result = result.title()
    return result

  def _product(self, banner):
    if banner:
      r=self._make_dict(banner)
      return r['product'] if 'product' in r else 'unknown'
    else:
      return "unknown"

  def _make_dict(self, s):
    chunks = re.split('\s*(\w+\:)\s*',s)
    res={}
    args=[reversed(chunks)]*2
    for value,key in zip(*args):
      key=key.rstrip(':')
      if value:
        res[key]=value
      else:
        res={key:res}
    return res

  def _store_in_db(self, scan, reaper=False, notes=None, tags=None):
    if reaper and not self._getSetting("reaper.store", False):
      return
    # Hash calculation to prevent duplicates
    sha1=codecs.encode(hashlib.sha1(json.dumps(scan).encode('utf-8')).digest(), "hex").decode("utf-8")
    if not db.p_queryData(self.collection, {'sha1': sha1}):
      data={"scan": scan, "sha1": sha1}
      if type(notes) == str: data["notes"] = notes
      if type(tags) == list: data["tags"]  = tags
      db.p_addEntry(self.collection, data)
      return True
    return False

  def _getSetting(self, setting, default):
    s = db.p_readSetting(self.collection, setting)
    if not s:
      db.p_writeSetting(self.collection, setting, default)
      s = default
    return s

class PDFGenerationException(Exception): pass
