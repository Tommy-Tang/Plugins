## Minimum required imports
import base64
import os
import json
import sys
import re
import traceback
import __main__
callLocation = os.path.dirname(os.path.realpath(__main__.__file__))
sys.path.append(os.path.join(callLocation, ".."))

from bson           import json_util
from datetime       import datetime
from libnmap.parser import NmapParser
from uuid           import uuid4
from jinja2         import Environment, FileSystemLoader
from weasyprint     import HTML
from flask          import Flask, render_template

import lib.CVEs as cves
import lib.DatabaseLayer as dbLayer
from lib.Plugins import Plugin, WebPlugin
from lib.Toolkit import toStringFormattedCPE

class CVEScan(WebPlugin):
  def __init__(self):
    self.name = "CVE-Scan"
    self.requiresAuth = False
    self.tempPath = "/tmp/CVEScan-pdfs"

    env = Environment(loader=FileSystemLoader(callLocation))
    self.pdf  = env.get_template("templates/plugins/cve-scan_pdf.html")
    self.html = "plugins/cve-scan_webdisplay.html"

  def onCVEAction(self, cve, action, **args):
    if action not in ["json", "pdf", "webview"]:
      return False
    try:
      data     = args["fields"]['scan'][0]
      nmap     = self._parseNMap(data)
      enhanced = self._enhance(nmap)
      if   action == "json":
        returndata = json.dumps(enhanced, indent=2, default=json_util.default)
      elif action == "pdf":
        returndata = str(base64.b64encode(self._generatePDF(enhanced)), "utf-8")
      elif action == "webview":
        app = Flask(__name__, template_folder=os.path.join(callLocation, "templates"))
        with app.test_request_context("/"):
          returndata = render_template(self.html, scan=enhanced)
      return {'status': 'plugin_action_complete', 'data': returndata}
    except Exception as e:
      traceback.print_exc()
    return False

  def getPage(self, **args):
    return ("cve-scan.html", {'plug_id': self.getUID()})

  # CVE Scan code
  def _parseNMap(self, data):
    try:
      report = NmapParser.parse_fromstring(data)
    except Exception as e:
      print(e)
      raise(Exception)
    systems = []
    for h in report.hosts:
      system = {'mac':h.mac, 'ip':h.address, 'status':h.status, 'hostnames': h.hostnames,
                'vendor':h.vendor, 'distance':h.distance}
      cpeList = []
      for c in h.os_match_probabilities():
        for x in c.get_cpe():
          cpeList.append(x)
      cpeList=list(set(cpeList))
      if len(cpeList)>0:
        system['cpes']=cpeList
      services = []
      for s in h.services:
        service={'port':s.port, 'banner':s.banner, 'protocol':s.protocol, 'name':s.service,
                 'state':s.state, 'reason':s.reason}
        if s.cpelist:
          service['cpe'] = s.cpelist[0].cpestring
        services.append(service)
      system['services']=services
      systems.append(system)
    scan={"systems":systems, "scan": {"time": report.endtime, 
                                      "type": report._nmaprun["args"]}}
    return scan

  def _enhance(self, scan):
    cvesp = cves.last(rankinglookup=False, namelookup=False, vfeedlookup=True, capeclookup=False)
    for system in scan['systems']:
      cpe=system['cpes'] if 'cpes' in system else None
      
      if cpe:
        cpes=[]
        for c in cpe:
          c=c.lower()
          cpes.append({'cpe':c, 'cves':[cvesp.getcve(x['id'])
                       for x in dbLayer.cvesForCPE(toStringFormattedCPE(c))]})
        system['cpes']=cpes
      for service in system['services']:
        if 'cpe' in service:
          service['cves']=dbLayer.cvesForCPE(service['cpe'])
    scan['enhanced']={"time": int(datetime.now().strftime('%s'))}
    return scan

  def _generatePDF(self, parsed):
    try:
      filename = os.path.join(self.tempPath, "%s.pdf"%str(uuid4()))
      if not os.path.exists(self.tempPath): os.makedirs(self.tempPath)
      self._pdfify(parsed, filename)
      return open(filename, "rb").read()
    except Exception as e:
      print(e)
      raise(PDFGenerationException)

  def _pdfify(self, enhanced, output):
    enhanced["scan"]["time"] = self._fromEpoch(enhanced["scan"]["time"])
    enhanced["enhanced"]["time"] = self._fromEpoch(enhanced["enhanced"]["time"])
    appendixes=[]
    appendix = 1
    for system in enhanced["systems"]:
      if "cpes" in system:
        for cpe in system["cpes"]:
          cpe["cpe"] = self._toHuman(cpe["cpe"])
          if "cves" in cpe and len(cpe["cves"])!=0:
            appendixes.append(cpe["cves"])
            cpe.pop("cves")
            cpe["appendix"]=appendix
            appendix += 1
      for service in system["services"]:
        service["banner"]=self._product(service["banner"])
        if "cves" in service and len(service["cves"])!=0:
          appendixes.append(service["cves"])
          service["appendix"] = appendix
          appendix += 1
        if "cves" in service: service.pop("cves")
    enhanced["appendixes"]=appendixes
    html_out = self.pdf.render(enhanced)
    HTML(string=html_out).write_pdf(output)

  def _fromEpoch(self, epoch):
    return datetime.fromtimestamp(epoch).strftime('%a %d %h %Y at %H:%M:%S')

  def _toHuman(self, cpe):
    cpe = cpe[7:]
    result = cpe.split(':')[0] + " - "
    for c in cpe.split(':')[1:]:
      c = c.replace(':', ' ')
      c = c.replace('_', ' ')
      result += (" %s" %(c))
    result = result.title()
    return result

  def _product(self, banner):
    if banner:
      r=self._make_dict(banner)
      return r['product'] if 'product' in r else 'unknown'
    else:
      return "unknown"

  def _make_dict(self, s):
    chunks = re.split('\s*(\w+\:)\s*',s)
    res={}
    args=[reversed(chunks)]*2
    for value,key in zip(*args):
      key=key.rstrip(':')
      if value:
        res[key]=value
      else:
        res={key:res}
    return res

class PDFGenerationException(Exception): pass
